# Лабораторна робота №1 - Пояснення фундаментальних патернів проєктування

1. ImmutablePattern це патерн проєктування, який забезпечує створення незмінних об’єктів.
   Суть патерну: поля об’єкта не можуть бути змінені після його створення.
   У коді-прикладу клас ComputerMouse має два поля: model (String) і dpi (int).
   Вони оголошені як final, що означає, що їх значення можна встановити лише один раз - під час створення об’єкта.
   Їх можна прочитати за допомогою геттерів (getModel() і getDpi()), але не можна змінити, оскільки немає сеттерів.
   Коли застосовувати цей патерн: наприклад, коли потрібно створити об’єкти, які не повинні змінюватися після створення,
   тобто для забезпечення цілісності даних і уникнення неочікуваних змін.

2. InterfacePattern це патерн проєктування, який потрібен для визначення того, які методи повинен реалізовувати клас.
   Суть патерну: інтерфейс визначає те, що клас повинен робити, але не те, як він це робить.
   У коді-прикладу інтерфейс Peripheral має два методи: connect() і disconnect().
   Вони визначають поведінку периферійних пристроїв, але не містять реалізації.
   Клас Keyboard і клас Monitor реалізують цей інтерфейс, надаючи конкретну реалізацію методів connect() і disconnect().
   Обидва класи мають свою власну логіку підключення і відключення.
   В класах, які реалізують інтерфейс, потрібно використовувати всі методи, визначені в інтерфейсі.
   Коли застосовувати цей патерн: коли потрібно визначити спільну поведінку для різних класів.

3. abstractSuperClass це патерн проєктування, який використовується для створення базового класу,
   який містить спільну логіку для підкласів.
   Суть патерну: абстрактний клас може містити як абстрактні методи (без реалізації),
   так і конкретні методи (з реалізацією).
   У коді-прикладу абстрактний клас AbstractPrinter має абстрактний метод print() і конкретні методи turnOn() і turnOff().
   Він визначає спільну поведінку для всіх принтерів, але залишає реалізацію методу print() підкласам.
   Клас ModernPrinter це підклас AbstractPrinter, який реалізує метод print() і успадковує методи turnOn() і turnOff().
   Коли застосовувати цей патерн: коли існує спільна логіка і функціональність для кількох класів,
   але кожен клас має свою власну специфіку і реалізацію деяких методів.

4. DelegationPattern це патерн проєктування, який дозволяє одному об’єкту делегувати виконання
   певних завдань іншому об’єкту.
   Суть патерну: один об’єкт передає відповідальність за виконання певної задачі іншому об’єкту.
   У коді-прикладу клас Computer безпосередньо не може самостійно відтворювати звук, а натомість
   делегує цю задачу Speaker.
   Клас Speaker має метод playSound(), який містить логіку для відтворення звуку.
   Коли застосовувати цей патерн: коли потрібно розділити відповідальність між різними об’єктами та
   уникнути дублювання коду в різних класах.
